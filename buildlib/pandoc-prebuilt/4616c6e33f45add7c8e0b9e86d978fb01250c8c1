.\"t
.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "mlx5dv_dek_create / mlx5dv_dek_query / mlx5dv_dek_destroy" "3" "" "" ""
.hy
.SH NAME
.PP
mlx5dv_dek_create - Creates a DEK
.PP
mlx5dv_dek_query - Queries a DEK\[cq]s attributes
.PP
mlx5dv_dek_destroy - Destroys a DEK
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <infiniband/mlx5dv.h>

struct mlx5dv_dek *mlx5dv_dek_create(struct ibv_context *context,
                     struct mlx5dv_dek_init_attr *init_attr);

int mlx5dv_dek_query(struct mlx5dv_dek *dek, struct mlx5dv_dek_attr *attr);

int mlx5dv_dek_destroy(struct mlx5dv_dek *dek);
\f[R]
.fi
.SH DESCRIPTION
.PP
Data Encryption Keys (DEKs) are used to encrypt and decrypt transmitted
data.
After a DEK is created, it can be configured in MKeys for crypto offload
operations.
DEKs are not persistent and are destroyed upon process exit.
Therefore, software process needs to re-create all needed DEKs on
startup.
.PP
\f[B]mlx5dv_dek_create()\f[R] creates a new DEK with the attributes
specified in \f[I]init_attr\f[R].
A pointer to the newly created dek is returned, which can be used for
DEK query, DEK destruction and when configuring a MKey for crypto
offload operations.
.PP
The DEK can be either wrapped or in plaintext and the format that should
be used is determined by the specified crypto_login object.
.PP
To create a wrapped DEK, the application must have a valid crypto login
object prior to creating the DEK.
Creating a wrapped DEK can be performed in two ways: 1.
Call \f[B]mlx5dv_crypto_login_create()\f[R] to obtain a crypto login
object.
Indicate that the DEK is wrapped by setting
\f[B]MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN\f[R] value in \f[I]comp_mask\f[R]
and passing the crypto login object in \f[I]crypto_login\f[R] field of
\f[I]init_attr\f[R].
Fill the other DEK attributes and create the DEK.
.IP "2." 3
Call \f[B]mlx5dv_crypto_login()\f[R] i.e., the old API.
Supply credential, import_kek_id
.PP
To create a plaintext DEK, the application must indicate that the DEK is
in plaintext by setting \f[B]MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN\f[R]
value in \f[I]comp_mask\f[R] and passing NULL value in
\f[I]crypto_login\f[R] field of \f[I]init_attr\f[R], fill the other DEK
attributes and create the DEK.
.PP
To use the created DEK (either wrapped or plaintext) in a MKey, a valid
crypto login object or session is not needed.
Revoking the import KEK or credential that were used for the crypto
login object or session (and therefore rendering the crypto login
invalid) does not prevent using a created DEK.
.PP
\f[B]mlx5dv_dek_query()\f[R] queries the DEK specified by \f[I]dek\f[R]
and returns the queried attributes in \f[I]attr\f[R].
A valid crypto login object or session is not required to query a
plaintext DEK.
On the other hand, to query a wrapped DEK a valid crypto login object or
session must be present.
.PP
\f[B]mlx5dv_dek_destroy()\f[R] destroys the DEK specified by
\f[I]dek\f[R].
.SH ARGUMENTS
.SS context
.PP
The device context to create the DEK with.
.SS init_attr
.IP
.nf
\f[C]
enum mlx5dv_dek_init_attr_mask {
    MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN = 1 << 0,
};

struct mlx5dv_dek_init_attr {
    enum mlx5dv_crypto_key_size key_size;
    bool has_keytag;
    enum mlx5dv_crypto_key_purpose key_purpose;
    struct ibv_pd *pd;
    char opaque[8];
    char key[128];
    uint64_t comp_mask; /* Use enum mlx5dv_dek_init_attr_mask */
    struct mlx5dv_crypto_login_obj *crypto_login;
};
\f[R]
.fi
.TP
\f[I]key_size\f[R]
The size of the key, can be one of the following
.RS
.TP
\f[B]MLX5DV_CRYPTO_KEY_SIZE_128\f[R]
Key size is 128 bit.
.TP
\f[B]MLX5DV_CRYPTO_KEY_SIZE_256\f[R]
Key size is 256 bit.
.RE
.TP
\f[I]has_keytag\f[R]
Whether the DEK has a keytag or not.
If set, the key should include a 8 Bytes keytag.
Keytag is used to verify that the DEK being used by a MKey is the
expected DEK.
This is done by comparing the keytag that was defined during DEK
creation with the keytag provided in the MKey crypto configuration, and
failing the operation if they are different.
.TP
\f[I]key_purpose\f[R]
The purpose of the key, currently can only be the following value
.RS
.TP
\f[B]MLX5DV_CRYPTO_KEY_PURPOSE_AES_XTS\f[R]
The key will be used for AES-XTS crypto engine.
.RE
.TP
\f[I]pd\f[R]
The protection domain to be associated with the DEK.
.TP
\f[I]opaque\f[R]
Plaintext metadata to describe the key.
.TP
\f[I]key\f[R]
The key that will be used for encryption and decryption of transmitted
data.
For plaintext DEK \f[I]key\f[R] must be provided in plaintext.
For wrapped DEK \f[I]key\f[R] must be provided wrapped by the import KEK
that was specified in the crypto login.
Actual size and layout of this field depend on the provided
\f[I]key_size\f[R] and \f[I]has_keytag\f[R] fields, as well as on the
format of the key (plaintext or wrapped).
\f[I]key\f[R] should be constructed according to the following table.
.RS
.PP
DEK \f[I]key\f[R] Field Construction.
.TS
tab(@);
l l l l.
T{
Import Method
T}@T{
Has Keytag
T}@T{
Key size
T}@T{
Key Layout
T}
_
T{
Plaintext
T}@T{
No
T}@T{
128 Bit
T}@T{
key1_128b + key2_128b
T}
T{
T}@T{
T}@T{
T}@T{
T}
T{
Plaintext
T}@T{
No
T}@T{
256 Bit
T}@T{
key1_256b + key2_256b
T}
T{
T}@T{
T}@T{
T}@T{
T}
T{
Plaintext
T}@T{
Yes
T}@T{
128 Bit
T}@T{
key1_128b + key2_128b + keytag_64b
T}
T{
T}@T{
T}@T{
T}@T{
T}
T{
Plaintext
T}@T{
Yes
T}@T{
256 Bit
T}@T{
key1_256b + key2_256b + keytag_64b
T}
T{
T}@T{
T}@T{
T}@T{
T}
T{
Wrapped
T}@T{
No
T}@T{
128 Bit
T}@T{
ENC(iv_64b + key1_128b + key2_128b)
T}
T{
T}@T{
T}@T{
T}@T{
T}
T{
Wrapped
T}@T{
No
T}@T{
256 Bit
T}@T{
ENC(iv_64b + key1_256b + key2_256b)
T}
T{
T}@T{
T}@T{
T}@T{
T}
T{
Wrapped
T}@T{
Yes
T}@T{
128 Bit
T}@T{
ENC(iv_64b + key1_128b + key2_128b + keytag_64b)
T}
T{
T}@T{
T}@T{
T}@T{
T}
T{
Wrapped
T}@T{
Yes
T}@T{
256 Bit
T}@T{
ENC(iv_64b + key1_256b + key2_256b + keytag_64b)
T}
.TE
.PP
Where ENC() is AES key wrap algorithm and iv_64b is 0xA6A6A6A6A6A6A6A6
as per the NIST SP 800-38F AES key wrap spec.
.PP
The following example shows how to wrap a 128 bit key that has keytag
using a 128 bit import KEK in OpenSSL:
.IP
.nf
\f[C]
#include <openssl/evp.h>

unsigned char import_kek[16]; /* 128 bit import KEK in plaintext for wrapping */
unsigned char iv[8] = {0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6};

/*
 * Indexes 0-15 are key1 in plaintext, indexes 16-31 are key2 in plaintext,
 * and indexes 32-39 are key_tag in plaintext.
 */
unsigned char key[40];

unsigned char wrapped_key[48];
EVP_CIPHER_CTX *ctx;
int len;

ctx = EVP_CIPHER_CTX_new();
EVP_CIPHER_CTX_set_flags(ctx, EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);
EVP_EncryptInit_ex(ctx, EVP_aes_128_wrap(), NULL, import_kek, iv);
EVP_EncryptUpdate(ctx, wrapped_key, &len, key, sizeof(key));
EVP_EncryptFinal_ex(ctx, wrapped_key + len, &len);
EVP_CIPHER_CTX_free(ctx);
\f[R]
.fi
.RE
.TP
\f[I]comp_mask\f[R]
Currently can be the following value:
.RS
.PP
\f[B]MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN\f[R], which indicates that
\f[I]crypto_login\f[R] field is applicable.
.RE
.TP
\f[I]crypto_login\f[R]
Pointer to a crypto login object.
If set to a valid crypto login object, indicates that this is a wrapped
DEK that will be created using the given crypto login object.
If set to NULL, indicates that this is a plaintext DEK.
Must be NULL if \f[B]MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN\f[R] is not set.
Only relevant when comp_mask is set with
\f[I]MLX5DV_DEK_INIT_ATTR_CRYPTO_LOGIN\f[R]
.SS dek
.IP
.nf
\f[C]
Pointer to an existing DEK to query or to destroy.
\f[R]
.fi
.SS attr
.IP
.nf
\f[C]
DEK attributes to be populated when querying a DEK.
\f[R]
.fi
.IP
.nf
\f[C]
struct mlx5dv_dek_attr {
    enum mlx5dv_dek_state state;
    char opaque[8];
    uint64_t comp_mask;
};
\f[R]
.fi
.TP
\f[I]state\f[R]
The state of the DEK, can be one of the following
.RS
.TP
\f[B]MLX5DV_DEK_STATE_READY\f[R]
The key is ready for use.
This is the state of the key when it is first created.
.TP
\f[B]MLX5DV_DEK_STATE_ERROR\f[R]
The key is unusable.
The key needs to be destroyed and re-created in order to be used.
This can happen, for example, due to DEK memory corruption.
.RE
.TP
\f[I]opaque\f[R]
Plaintext metadata to describe the key.
.TP
\f[I]comp_mask\f[R]
Reserved for future extension, must be 0 now.
.SH RETURN VALUE
.PP
\f[B]mlx5dv_dek_create()\f[R] returns a pointer to a new \f[I]struct
mlx5dv_dek\f[R] on success.
On error NULL is returned and errno is set.
.PP
\f[B]mlx5dv_dek_query()\f[R] returns 0 on success and updates
\f[I]attr\f[R] with the queried DEK attributes.
On error errno value is returned.
.PP
\f[B]mlx5dv_dek_destroy()\f[R] returns 0 on success and errno value on
error.
.SH SEE ALSO
.PP
\f[B]mlx5dv_crypto_login\f[R](3),
\f[B]mlx5dv_crypto_login_create\f[R](3),
\f[B]mlx5dv_query_device\f[R](3)
.SH AUTHORS
.PP
Avihai Horon <avihaih@nvidia.com>
